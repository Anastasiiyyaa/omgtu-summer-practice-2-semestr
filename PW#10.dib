#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №10. Доставка сообщений до Команды.

**Цель:** Предоставить возможность обмена данными для длительных операций.

**Результаты:** После выполнения работы Вы сможете:
1. Отправлять сообщения длительной операции.

## Задание.
Поскольку длительная операция выполняется в течение некоторого момента времени, то может возникнуть необходимость
в предоставлении дополнительной информации, влияющей на ход выполнения. Поскольку Команды и источник данных часто находятся в разных потоках,
то сделать это надо потоко-безопасным образом. Самый простой способ - используя идиому Производитель-Поребитель, в нашем случае - очередь.

Набор данных, предназначенных для Команды будем называть сообщением. Можно использовать любую подходящую конструкцию языка программирования для 
представления сообщения. Необходимо учесть, что скорость доставки сообщений может быть выше, чем скорость обработки, а значит очередь сообщений должна быть
у каждой Длительной операции. При этом потоко-безопасные очереди требуют системных ресурсов, а значит, чтобы не получить ограничение на максимальное количество
одновремнно работающих длительных Команд, нельзя использовать потоко-безопасные очереди. 

Возможный вариант реализации - оставить одну потоко-безопасную очередь для потока, а для Команд использовать обычные очереди. Осталось только решить, как сообщение
излеченное из очереди потока попадет в очередь Команды. Один из возможных вариантов:
1. Каждая команда имеет уникальный идентификатор.
2. Сообщение содержит уникальный идентификатор Команлды, которому оно адресовано.
3. Для потока создаем специальную Длительную Команду, которая назвается Роутером. Он хранит коллекцию пар (id Команды, ссылка на очередь Команды). При вызове метода Execute этой 
Роутера, если очередь потока не пуста, происходит чтение очередного сообщения и по id Команды определяется очередь, куда это сообщение записывается.
Если id Команды не определен, на консоль выводится сообщение о невозможности доставить сообщение неизвестному адресату.
При старте новой Команды, ее очередь необходимо добавить в коллекцию Роутера. При остановке Команды - очередь удаляется из коллекции Роутера.

Продемонстрировать работу Роутера на двух Длительных Командах и на отправке сообщения несуществующей Команде.

#!csharp

using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Threading;

public interface ICommand
{
    void Execute(Message message);
    int Count { get; set; }
}

public class HardStopCommand : ICommand
{
    public int Count { get; set; } = 1;

    public void Execute(Message message)
    {
        Console.WriteLine("Выполняется HardStop");
        throw new ThreadInterruptedException();
    }
}

public class SoftStopCommand : ICommand
{
    public int Count { get; set; } = 1;

    public void Execute(Message message)
    {
        Console.WriteLine("Выполняется SoftStop");
    }
}

public class TestCommand : ICommand
{
    private int id;
    private int counter = 0;

    public TestCommand(int id)
    {
        this.id = id;
    }

    public int Count { get; set; } = 3;

    public void Execute(Message message)
    {
        Console.WriteLine($"Поток {id} вызов {++counter}");
        Console.WriteLine($"Получено сообщение: {message.Content}");
    }
}

public class Message
{
    public string Content { get; set; }
    public int CommandId { get; set; }
}

public interface IScheduler
{
    bool HasCommand();
    ICommand Select();
    void Add(ICommand cmd);
}

public class RoundRobinScheduler : IScheduler
{
    private ConcurrentQueue<ICommand> commands = new ConcurrentQueue<ICommand>();

    public bool HasCommand()
    {
        return !commands.IsEmpty;
    }

    public ICommand Select()
    {
        if (commands.TryDequeue(out ICommand command))
        {
            return command;
        }
        return null;
    }

    public void Add(ICommand cmd)
    {
        commands.Enqueue(cmd);
    }
}

public class ServerThread
{
    private ConcurrentQueue<Message> newMessages = new ConcurrentQueue<Message>();
    private IScheduler scheduler = new RoundRobinScheduler();
    private Thread thread;
    private bool isRunning = false;
    private Router router = new Router();

    public ServerThread()
    {
        thread = new Thread(Run);
        thread.Start();
    }

    public void EnqueueMessage(Message message)
    {
        newMessages.Enqueue(message);
    }

    public void EnqueueCommand(ICommand command)
    {
        newMessages.Enqueue(new Message { Content = "Command", CommandId = -1 });
    }

    public void HardStop()
    {
        if (Thread.CurrentThread == thread)
        {
            EnqueueCommand(new HardStopCommand());
        }
        else
        {
            throw new InvalidOperationException("HardStop может быть вызван только в текущем потоке");
        }
    }

    public void SoftStop()
    {
        if (Thread.CurrentThread == thread)
        {
            EnqueueCommand(new SoftStopCommand());
        }
        else
        {
            throw new InvalidOperationException("SoftStop может быть вызван только в текущем потоке");
        }
    }

    private void Run()
    {
        isRunning = true;
        try
        {
            while (isRunning)
            {
                if (newMessages.TryDequeue(out Message message))
                {
                    if (message.CommandId == -1)
                    {
                        scheduler.Add(new HardStopCommand());
                    }
                    else
                    {
                        scheduler.Add(router);
                    }
                }

                while (scheduler.HasCommand())
                {
                    try
                    {
                        ICommand command = scheduler.Select();
                        if (command != null)
                        {
                            command.Execute(message);
                            command.Count--;
                            if (command.Count > 0)
                            {
                                scheduler.Add(command);
                            }
                        }
                        else
                        {
                            Thread.Sleep(10);
                            break;
                        }
                    }
                    catch (ThreadInterruptedException)
                    {
                        Console.WriteLine("Поток завершен");
                        isRunning = false;
                        break;
                    }
                }
            }
        }
        finally
        {
            isRunning = false;
        }
    }

    public Thread GetThread() => thread;

    public Router Router
    {
        get { return router; }
    }
}

public class Router : ICommand
{
    private Dictionary<int, ICommand> commands = new Dictionary<int, ICommand>();

    public int Count { get; set; } = 1;

    public void Execute(Message message)
    {
        if (commands.TryGetValue(message.CommandId, out ICommand command))
        {
            command.Execute(message);
        }
        else
        {
            Console.WriteLine($"Невозможно доставить сообщение {message.Content} для неизвестной команды с id {message.CommandId}");
        }
    }

    public ICommand GetCommand(int commandId)
    {
        commands.TryGetValue(commandId, out ICommand command);
        return command;
    }

    public void AddCommand(int commandId, ICommand command)
    {
        commands[commandId] = command;
    }

    public void RemoveCommand(int commandId)
    {
        commands.Remove(commandId);
    }
}

var serverThread = new ServerThread();

var command1 = new TestCommand(1);
var command2 = new TestCommand(2);
serverThread.Router.AddCommand(1, command1);
serverThread.Router.AddCommand(2, command2);
serverThread.EnqueueMessage(new Message { Content = "Message 1", CommandId = 1 });
serverThread.EnqueueMessage(new Message { Content = "Message 2", CommandId = 2 });
serverThread.EnqueueMessage(new Message { Content = "Message 3", CommandId = 3 });
serverThread.EnqueueCommand(new HardStopCommand());
serverThread.GetThread().Join();

#!markdown

**Материалы для самостоятельного изучения**.
1. [Паттерн Сообщение](https://www.enterpriseintegrationpatterns.com/patterns/messaging/Message.html)
2. [Паттерн Роутер - весь раздел про Роутеры](https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageRoutingIntro.html)
3. [Обмен сообщеними](https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageConstructionIntro.html)
